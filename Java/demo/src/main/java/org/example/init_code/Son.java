package org.example.init_code;

/*
 * 子类的初始化<clinit>：
 * （1）j = method();
 * （2）子类的静态代码块
 *
 * 先初始化父类：(5)(1)
 * 初始化子类：（10）(6)
 *
 * 子类的实例化方法<init>：
 * （1）super()（最前）      （9）（3）（2）
 * （2）i = test();    （9）
 * （3）子类的非静态代码块    （8）
 * （4）子类的无参构造（最后） （7）
 *
 * 因为创建了两个Son对象，因此实例化方法<init>执行两次
 *
 * （9）（3）（2）（9）（8）（7）
 */
public class Son extends Father{
    private int i = test();
    private static int j = method();
    static{
        System.out.print("(6)");
    }
    Son(){
//		super();//写或不写都在，在子类构造器中一定会调用父类的构造器
        System.out.print("(7)");
    }
    {
        System.out.print("(8)");
    }
    public int test(){
        System.out.print("(9)");
        return 1;
    }
    public static int method(){
        System.out.print("(10)");
        return 1;
    }
    public static void main(String[] args) {
        Son s1 = new Son();
        System.out.println();
        Son s2 = new Son();

        /**
         *
         * 解析一
         *
         * 这段Java代码是用来演示Java中对象的初始化和实例化过程的。包括静态初始化和非静态初始化（实例初始化）。
         *
         * 在这个代码中，有一个父类Father和一个子类Son。每个类中都有静态变量、静态代码块、非静态变量、非静态代码块和构造方法。并且Father类中的test方法被Son类重写。
         *
         * 下面会详细解释这段代码，以及为什么会得到这样的结果：
         *
         *      1. 静态初始化：<clinit>方法
         *      静态初始化在类加载阶段执行，且只执行一次。它包括静态变量的初始化和静态代码块。这些内容在类加载时按照它们在代码中出现的顺序执行。因为Son类继承了Father类，所以Father类的静态初始化会在Son类的静态初始化之前执行。
         *
         *      2. 实例初始化：<init>方法
         *      实例初始化在每次创建类的新实例（即新对象）时执行。它包括非静态变量的初始化、非静态代码块和构造方法。这些内容在实例初始化时也是按照它们在代码中出现的顺序执行。并且构造方法的执行是在这些内容之后的，也就是最后执行。
         *
         * 现在来解释输出结果：
         *
         * (5)(1)(10)(6) 是静态初始化的结果。首先执行Father的静态初始化，输出(5)(1)，然后执行Son的静态初始化，输出(10)(6)。
         *
         * 接着是实例初始化的结果。首先创建第一个Son对象s1：
         *
         * (9)(3)(2)(9)(8)(7) 是实例初始化的结果。首先执行Father的实例初始化，其中test()方法被Son重写，所以输出(9)(3)(2)，然后执行Son的实例初始化，输出(9)(8)(7)。
         *
         * 然后创建第二个Son对象s2，实例初始化的过程和s1一样，所以输出结果也一样，是(9)(3)(2)(9)(8)(7)。
         *
         * 所以最终的输出结果是(5)(1)(10)(6)(9)(3)(2)(9)(8)(7)(9)(3)(2)(9)(8)(7)。
         *
         * 这段代码很好地展示了Java中对象的初始化和实例化过程，以及在这个过程中方法重写和子类继承父类的影响。
         */

        /**
         * 解析二
         *
         * 首先，我们需要理解Java类的加载顺序：
         *
         * 父类的静态变量和静态代码块（按在代码中出现的顺序）
         * 子类的静态变量和静态代码块（按在代码中出现的顺序）
         * 父类的非静态变量和非静态代码块（按在代码中出现的顺序）
         * 父类的构造方法
         * 子类的非静态变量和非静态代码块（按在代码中出现的顺序）
         * 子类的构造方法
         * 接下来，我们以这个顺序解析执行过程：
         *
         * 静态初始化阶段：
         *
         * 首先加载Father类，初始化其静态变量j，执行method()，输出(5)，然后执行静态代码块，输出(1)。所以在Father类加载完毕后，输出的是(5)(1)。
         *
         * 接着加载Son类，同样先初始化静态变量j，执行method()，输出(10)，然后执行静态代码块，输出(6)。所以在Son类加载完毕后，输出的是(10)(6)。
         *
         * 实例化阶段：
         *
         * 接下来，执行main方法，首先实例化Son对象s1。在实例化过程中，首先初始化Father的部分，即先执行test()方法（这里由于多态性，实际上执行的是Son类中重写的test()方法），输出(9)，然后执行Father的非静态代码块，输出(3)，最后执行Father的构造方法，输出(2)。所以在Father的实例化部分完成后，输出的是(9)(3)(2)。
         *
         * 然后初始化Son的部分，同样先执行test()方法，输出(9)，然后执行Son的非静态代码块，输出(8)，最后执行Son的构造方法，输出(7)。所以在Son的实例化部分完成后，输出的是(9)(8)(7)。
         *
         * 所以在第一个Son对象s1实例化完毕后，输出的是(9)(3)(2)(9)(8)(7)。
         *
         * 在创建第二个Son对象s2时，由于静态初始化只在类加载时执行一次，所以这里只需要进行实例化部分，输出的结果和s1一样，也是(9)(3)(2)(9)(8)(7)。
         *
         * 所以，完整的输出结果就是(5)(1)(10)(6)(9)(3)(2)(9)(8)(7)(9)(3)(2)(9)(8)(7)。
         *
         * 通过这段代码，我们可以清楚地看到在Java中类加载、初始化以及对象实例化的过程和顺序，以及多态性在这个过程中的表现。
         */
    }
}
